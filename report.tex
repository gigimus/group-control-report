\documentclass[a4paper,14pt,russian]{article}

\usepackage{extsizes}
\usepackage{cmap} % для кодировки шрифтов в pdf
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage[T1,T2A]{fontenc}

\usepackage{graphicx} % для вставки картинок
\usepackage{amssymb,amsfonts,amsmath,amsthm} % математические дополнения от АМС
\usepackage{indentfirst} % отделять первую строку раздела абзацным отступом тоже
\usepackage[usenames,dvipsnames]{color} % названия цветов
\usepackage{makecell}
\usepackage{multirow} % улучшенное форматирование таблиц

\usepackage{hyperref}
\usepackage{url}

% ituphanov: Поля вроде не прописаны. Они большие какие-то.
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

% ituphanov (2): Не понятно зачем ты это закомментировал. Вроде как в требованиях всегда был
% интервал полуторный.
\linespread{1.3} % полуторный интервал
\renewcommand{\rmdefault}{ftm} % Times New Roman
\frenchspacing

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage}
\fancyheadoffset{0mm}
\fancyfootoffset{0mm}
\setlength{\headheight}{17pt}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancypagestyle{plain}{
    \fancyhf{}
    \rhead{\thepage}}
\setcounter{page}{2}

\usepackage[tableposition=top]{caption}
\usepackage{subcaption}
\DeclareCaptionLabelFormat{gostfigure}{Рисунок #2}
\DeclareCaptionLabelFormat{gosttable}{Таблица #2}
\DeclareCaptionLabelSeparator{gost}{~---~}
\captionsetup{labelsep=gost}
\captionsetup[figure]{labelformat=gostfigure}
\captionsetup[table]{labelformat=gosttable}
\renewcommand{\thesubfigure}{\asbuk{subfigure}}


\begin{document}
\tableofcontents
\newpage

\section*{Аннотация}

В работе описывается программа для построения оптимального плана выполнения заданий несколькими аппаратами. Работа выполнена в рамках системы управления АНПА для подводных аппаратов ДВФУ и ИПМТ ДВО РАН. Рассмотрен ряд алгоритмов для реализации такого построения. Проведено их тестирование на сгенерированных и составленных в ручную тестах, после чего наиболее эффективные алгоритмы для различных размеров входных данных внедрены в систему управления.

\section{Введение}
\subsection{Глоссарий}
\begin{itemize}
% ituphanov (2): Здесь предлагаю поставить точку в конце каждого пункта.
\item АНПА -- Автономный необитаемый подводный аппарат \cite{auv}.
\item ИПМТ -- Институт проблем морских технологий ДВО РАН.
\item MTSP -- Multiple Traveling Salesman Problem или множественная задача коммивояжера \cite{bektas2006multiple}.
\item ГА -- генетический алгоритм \cite{ga}.
\end{itemize}

\subsection{Описание предметной области}

% ituphanov (2): Замечание по поводу спеллчекера остаётся. В тексте порядочное количество
% опечаток. Например, ниже написано "площдь".

Одна из областей применения автономных необитаемых подводных аппаратов заключается в решении обзорно-поисковых задач. В рамках таких задач аппаратами покрывается некоторая площдь под водой с целью, например, построения карты с нанесенными результатами измерений, либо с целью поиска и обследования заданных объектов.

В ИПМТ ДВО РАН и ДВФУ давно ведутся исследования по разработке более эффективных методов решения обзорно-поисковых задач с использованием подводных аппаратов.

В настоящее время ведутся исследования методов, которые позволят более эффективно решать обзорно-поисковые задачи засчет интеллектуализации аппаратов. Все больше методов концентрируются на эффективном использовании группы АНПА для решения подобных задач.

% ituphanov (2): В полноценном отчёте здесь можно сказать гораздо больше. О том, какие конкретно
% бывают задачи. Например, о поиске затонувших самолётов, обследовании шлейфов тёплой воды от
% АЭС. Я приложил эти два доклада, ссылки на них можно восстановить по названиям, например,
% через scholar.google.com.

\subsection{Неформальная поставнока задачи}

% описание конкретных предметных областей, примеры использования
% Часть взять из формальной постановке
% планирование в реальном времени, порядок величины миссии
% Перепланирование из-за различных сбоев или добавлений новых аппаратов
% время наработки на отказ
% батарея
% упоминание конкретных аппаратов
% Перепланирование по причине изменения входных данных (добавление-удаление аппаратов, изменение заданий, причины этого, добавление, удаление заданий)
% Почему модель учитывает некоторые факторы а некоторые - нет
% Улучшить в рамках существующей системы

Первоначальная задача заключалась в разработке и исследовании методов и алгоритмов организации работы в группе АНПА в рамках математической модели, предложенной в работе \cite{tuphanov}.
% ituphanov (2): Если ты хочешь вставить здесь ссылку на работу, то можно сделать какой-нибудь
% плэйсхоулдер. Желательно, не как у тебя это сделано ниже с помощью "фывафы", а, например,
% с помощью [], тогда это будет понятно и легко будет искать это в тексте.

% ituphanov (2): Как-то этот пункт странно сформулирован. То есть, вроде как подчёркивается,
% что была какая-то первоначальная постановка, но потом мы от неё оступили.

% ituphanov (2): В полноценном отчёте здесь можно сказать гораздо больше. Например, о том, что
% используется централизованное управление, о том что уже есть система, которая как-то работает,
% и для неё и исследуются алгоритмы.

% ituphanov (3): Да и помимо того что нужно объяснить, что за система существует, надо объяснить,
% в чём заключается проблема (в том что алгоритм тормозной), и нужно, собственно, неформально
% поставить задачу. То есть, что перед тобой ставилась цель: сделать так, чтобы система не
% тормозила, и приемлемо решала задачу. Из этой цели следуют задачи: исследовать алгоритмы,
% встроить их в систему управления.
% Время поворота, размеры лодок, реальные планы, карты
% Как покрываем площади?
% Почему решаем такую общую задачу.
% Почему разбиваем задачу на две (составление заданий и распределения), а не составляем сразу оптимальные траектории
% Предполагаем

\subsection{Обзор существующих решений}

% Поставить задачу MTSP и разные варианты

Существует большое множество алгоритмов, использующихся для решения задачи централизованного планирования заданий для группы аппаратов.

Все найденные подходы используют алгоритмы решения известной задачи дискретной оптимизации, MTSP, в разных ее вариантах. Такие подходы описаны например в \cite{bektas2006multiple}. В частности, в работе \cite{binaryprog} описан подход, основанный на применении целочисленного программирования к решению MTSP с различными исходными положениями аппаратов.

Однако, большинство методов находят приближенное решение множественной задачи коммивояжера, так как точные алгоритмы работают медленно. В работе \cite{kiraly2010novel} к решению MTSP применен генетический алгоритм, а в \cite{na2007heurisic} описаны эвристические методы распределения заданий между аппаратами с последующим решением задачи коммивояжера для каждого из них в отдельности.

% ituphanov (2): Порядок следующих двух абзацев надо поменять. Сначала надо сказать,
% что в лаб. НПА (ИПМТ вроде бы здесь не в теме, потому что МАРК им не принадлежит, но я точно
% не уверен) уже используется некоторая мат. модель (не надо говорить, что "была предложена
% новая мат. модель", надо просто сказать что она есть). А потом надо сказать, что там есть
% алгоритм, но он ищет точное решение и тормозит.

В ИПМТ ДВО РАН и ДВФУ для решения таких задач используют решение, описанное в работе \cite{tuphanov}. Данное решение является точным в рамках используемой модели, но работает слишком медленно для необходимого количество заданий и аппаратов. В связи с этим необходимо исследование других подходов к задаче группового управления.

Заказчиком также была предложена новая модель для постановки исходной задачи, в рамках которой и работает вышеупомянутое решение. Она также описана в работе \cite{tuphanov}. Ни один из найденных методов ее не рассматривает, поэтому некоторые из них решено было доработать для решения задачи в рамках новой модели.

\section{Математические методы}

\subsection{Постановка задачи}
Предполагается, что имеется $m$ аппаратов и $n$ заданий. Планирование происходит перед началом миссии. Известно, что $q$-ый аппарат в начальный момент времени находится в точке $s_q$ и готов к выполнению заданий. Вводится функция $d_q(\mathbf{a}, \mathbf{b})$, обозначающая время перехода АНПА от точки $\mathbf{a}$ к точке $\mathbf{b}$. Она принимает вид $d_q(\mathbf{a}, \mathbf{b}) = d(\mathbf{a}, \mathbf{b}) = |\mathbf{a} - \mathbf{b}|$. Для $i$-го задания дано $v_i$ вариантов его выполнения и $j$-ый вариант характеризуется тройкой $(\mathbf{a}_{i, j}, \mathbf{b}_{i,j}, l_{i,j})$, обозначающей соответственно точку начала задания, точку окончания и время его выполнения.

% Пример чему равно l_i_j, но мы не привязываемся, потому-то потому-то

Планом аппарата назван кортеж пар $p = (i_1, j_1), (i_2, j_2), ..., (i_{|p|}, j_{|p|})$ такой, что $i_k \in 1..n, j_k \in 1..v_{i_k}$, для всех $k \in 1..|p|$. Выполнение плана $q$-м аппаратом начинается в точке $\mathbf{s}_q$ и заканчивается в точке $\mathbf{b}_{i_{|p|}, j_{|p|}}$. Время выполнения аппаратом с номером $q$ плана $p$, составляет:

\begin{equation}
t_q(p_q) = d(\mathbf{s}_q, \mathbf{a}_{i_1, j_1}) + \sum_{k=2}^{|p|} d_q(\mathbf{b}_{i_{k-1}, j_{k - 1}}, \mathbf{a}_{i_k, j_k}) + \sum_{k=1}^{|p|}l_{i_k, j_k}
\end{equation}

% % соответствие между планами и аппаратами
Общим планом является кортеж планов $P = (p_1, p_2, ..., p_m)$ такой, что каждое здание встречается среди его планов один раз и в одном варианте. Время выполнения общего плана определяется выражением:

\begin{equation}
t(P) = \displaystyle \max_{q \in 1..m} t_q(p_q)
\end{equation}

Задача состоит в том, чтобы при данных стартовых позициях $\mathbf{s}_q$, известных заданиях и вариантах их выполнения найти общий план $P$, минимизирующий $t(P)$.

% Заданная функция d_q

% ituphanov (2): Вполне возможно, что далее по тексту надо будет ссылаться на задачу оптимизации.
% Тогда удобно сделать, чтобы она была выражено какой-то нумерованой формулой, поэтому может
% иметь смысл сделать формулу типа t(P) -> min.

\section{Требования}


% Столкновения бывают но мы о них забиываем
% Программа выполняется на ноутбуке, а не на аппарате

Программа должна:
\begin{itemize}
\item Реализовывать и сравнивать несколько алгоритмов решения задачи планирования
\item Быть совместимой с уже имеющимся API системы планирования заданий для группы подводных аппаратов ДВФУ.
% описать  API
\end{itemize}

Лучшие из реализованных алгоритмов для различных размеров входных данных требуется внедрить в уже использующуся систему планирования заданий для подводных аппаратов ДВФУ, работающую под операционными системами семейства Linux. В результате внедрения новых алгоритмов система должна:
\begin{itemize}

\item Осуществлять планирование до 100 заданий для группы до 5 аппратов за приемлимое время (до 1 минуты).
\item Выбирать более эффективный алгоритм в зависимости от размеров входных данных для планирования.
\item Допускается отклонение решения от оптимального на некоторых входных данных, в случае если алгоритм, дающий точное решение неэффективно на них работает.
\end{itemize}

% ituphanov (3): У меня есть подозрение, что раздел "алгоритмы" должен идти до раздела "проект".
% Можно даже сделать раздел "мат.методы и алгоритмы" и описать там и модель и алгоритмы.
% А раздел "требования" можно отнести чуть выше, поставить после неформальной постановки задачи.
% Если в репплане не так, то от репплана можно отступить.

\section{Проект}
\subsection{Объектно-ориентированная структура}
Система состоит из следующих модулей
\begin{itemize}
\item Task. Содержит классы:
    \begin{itemize}
    \item pnt. Содержит основной набор функций для работы с двумерными векторами в евклидовом пространстве. % ituphanov (2): Точка.
    \item assigned\_task. Содержит информацию об использованном варианте задания (начальная, конечная точки и время выполнения). % ituphanov (2): Точка. И слово таск надо заменить на литературное.
    \item task\_t. Содержит набор функций для работы с заданиями.
    \item tasks\_type. Контейнер для хранения заданий. Содержит функционал для добавления и доступа к заданиям.
    \end{itemize}
\item Solver. Содержит единственный класс basic\_solver, являющийся базовым ко всем классам, инкапсулирующим различные алгоритмы решения задачи планирования заданий для группы АНПА.
\item Plan. Содержит единственный класс plan\_t, который инкапсулирует работу с общим планом для всех аппаратов.
\item Data. Содержи тединственный класс problem\_data, содержащий входные данные к задаче и предоставляющий к ним доступ.
\item Visualize. Содержит класс visual\_frame, который служит для вывода заданного общего плана для группы аппаратов на экран.
\item MILPSolver. Содержит класс milp\_solver, в котором находится реализация алгоритма, основанного на целочисленном программировании.
\item GreedySolver. Содержит класс greedy\_solver, реализующий жадный подход к решению задачи планирования.
\item GeneticSolver. Содержит класс genetic\_solver, реализаующий генетический алгоритм для решения исходной задачи.
\item HKSolver. Содержит класс, содержащий реализацию алгоритма, описанного в asdfasdf
\end{itemize}

\subsection{Алгоритмы}
\subsubsection{Целочисленное программирование}

В настоящем разделе описывается алгоритм нахождения точного решения к поставленной задаче с помощью алгоритмов, использующих методы целочисленного программирвоания. В сравнении с вариантной моделью был сделан ряд упрощений:
% ituphanov (2): Вот здесь впервые употреблён термин "вариантная модель". Надо или выше ввести
% этот термин, там где ты вводишь модель, или ссылаться на неё как на "модель (1)-(3)".

% ituphanov (3): Нужно или поставить точку в конце каждого пункта перечисления, или
% сделать каждый пункт с маленькой буквы и после каждого кроме последнего ставить точку запятой.

\begin{itemize}
\item Все задания имеют ровно один вариант выполнения
\item У каждого задания начальная и конечная точки совпадают
\item Временные затраты на выполнение самих заданий аппаратами пренебрежимо малы
\item Скорости аппаратов одинаковы
\item Аппараты в начальный момент времени готовы к выполнению миссии
\item Для описания координат аппаратов и заданий используется двумерная декартова система координат
\end{itemize}


\paragraph{Сведение исходной задачи к MTSP} ~\\

Для постановки задачи MTSP необходимо ввести ориентированный граф.

Вершинами графа будут являться задания, стартовые вершины аппаратов и одна фиктивная вершина, необходимая только для постановки задачи коммивояжера.

От фиктивной вершины проведены ребра к стартовым вершинам аппаратов. От стартовых вершин аппаратов проведены ребра к каждой вершине заданий. Вершины заданий соединены ребрами между собой, образуя полный подграф. То есть ребра проведены между всеми парами вершин в обоих направлениях. Также, проведены ребра от вершин заданий к фиктивной вершине.

Весом каждого ребра будет расстояние между координатами заданий либо стартовых вершин. Вес ребер, инцидентных, фиктивной вершине равен нулю.

Решением задачи MTSP будет являться система циклов, удовлетворяющих требованиям MTSP, при этом стоимость максимального цикла будет минимально возможной. Каждому аппарату соответствует ровно один цикл. Двигаясь в этом цикле по направленным ребрам от стартовой вершины и заканчивая в фиктивной вершине, добавляя каждую вершину в план, мы получим оптимальный план этого аппарата.

% ituphanov (3): Если бы ты писал книгу (или статью), то несколько предыдущих абзацев точно
% надо было бы переделать. Потому что ты объяснил на пальцах и можно как-то не так это понять.
% Потому что встречаются словосочетания "вершина аппарата", и когда пытаешься понять что это
% такое, то видишь "стартовая вершина аппарата". При этом может создаться впечатление, что
% ты путаешь вершины графа и точки на плоскости (хотя, мы оба знаем, что не путаешь).
% Более правильным был бы способ описания, где ты ввёл бы обозначения для графа G, множества
% рёбер E, множества вершин V, подмножеств множества V, отвечающих за разные вещи,
% фиктивной вершины и т.д. и описал бы весовую функцию его рёбер. Какие-то из рёбер весят 0,
% какие-то - бесконечность, а какие-то ровно столько, каково расстояние между соответствующими
% точками на плоскости. Вершины можно также занумеровать (как ты это сделал ниже).
% Тогда можно нарисовать красивую матрицу для весовой функции, и использовать введённые
% обозначения ниже при описании задачи ЛП.
% Хорошо бы всё это сделать, если будет время.

Вставить пример графа.


\paragraph{Поставновка задачи целочисленного программирования} ~\\

Вводим бинарные переменные $x_{i,j,k}$, где $i, j$ -- номера вершин графа, $k$ -- номер аппарата. Полагаем $x_{i,j,k}$ равным единице, если в цикле, соответствующему аппарату $k$, есть ребро $(i, j)$, и нулю -- в противоположном случае. Вершина с индексом $0$ - фиктивная.

Добавляем следующие ограничения:
\begin{itemize}

\item Каждый аппарат должен иметь у себя в цикле ровно одно ребро, входящее в фиктивную вершину и выходящее из нее:

% ituphanov (3): Как-то в pdf-ке выглядит слепленной сумма и значок \forall k.
% Надо посмотреть как они в книжках по математике пишут. Там он тоже слеплен?

\begin{equation}
\forall k \displaystyle\sum_j x_{0,j,k} = \displaystyle\sum_i x_{i,0,k} = 1
\end{equation}

\item Сумма ребер, выходящих из любой вершины, кроме фиктивной, должна быть равна сумме ребер, входящих в нее и равна единице:
\begin{equation}
\forall i \neq 0 \displaystyle\sum_j \displaystyle\sum_k x_{i,j,k} = \displaystyle\sum_j \displaystyle\sum_k x_{j,i,k} = 1
\end{equation}

\end{itemize}

Обозначим вес ребра $(i, j)$ как $w_{i,j}$. Тогда стоимость маршрута каждого аппарата:
\begin{equation}
c_k(\mathbf{x}) = \displaystyle\sum_i \displaystyle\sum_j w_{i,j} x_{i,j,k}
\end{equation}

% ituphanov (3): В ограничениях и в целевой функции нигде не участвуют стартовые вершины
% аппаратов. Они могли исчезнуть, став обычными вершинами i, j, но тогда одному аппарату
% нельзя залезать на стартовую вершину другого. Или это само собой получается, потому что
% каждый аппарат и так стоит на своей стартовой вершине. В любом случае, на этот вопрос
% надо в тексте как-то ответить.

% ituphanov (3): Так где ты вводишь x i,j,k можно объяснить и что такое жирный x.

\begin{itemize}
\item В первом варианте алгоритма минимизируемым функционалом является
\begin{equation}
\widetilde{c}(\mathbf{x}) = \displaystyle\max_k \{c_k(\mathbf{x})\}
\end{equation}

\item Во втором варианте мы вводим переменную $C_{max}$, оптимальное значение котоорой ищем бинарным поиском. На каждой итерации бинарного поиска проверяем существование решения задачи целочисленного программирования, в которую добавлены ограничения $c_k(\mathbf{x}) \le C_{max}$ и минимизируемым функционалом является сумма:

% ituphanov (2): В этом выражении, равно как и в предыдущем, нет никакого знака "=". Это выглядит
% неудобно. Я бы рекомендовал ввести обозначение для минимизируемого функционала и написать
% что-то типа "f(x) = ...". Это делается потому что когда человек читает твой текст и привыкает
% к обозначениям, ему достаточно посмотреть на формулу и не пытаться что-то выудить из текста
% над ней.
\begin{equation}
\widetilde{c}(\mathbf{x}) = \displaystyle\sum_k c_k(\mathbf{x})
\end{equation}

\begin{equation}
\widetilde{c}(\mathbf{x}) \rightarrow \min
\end{equation}

\end{itemize}


\paragraph{Неравенства циклов} ~\\

При вышеописанной постановке задачи целочисленного программирования мы легко можем получить в качестве решения не один, а систему циклов для одного или нескольких аппаратов. Чтобы этого избежать, необходимо вводить дополнительные линейные ограничения исключающие появление систем циклов. В данной работе использовался следующий метод:
\begin{enumerate}
\item  Ожидаем решения задачи целочисленного программирования.
\item Анализируем решение на наличие систем циклов. Для этого используем поиск в глубину для каждого аппарата.
\item Если поиск в глубину находит цикл, длина которого меньше суммарного количества ребер, задействованных данным аппаратом, значит у данного аппарата в машруте есть несколько циклов.
% ituphanov (3): "$A$ - мн": здесь нужно вставить второй "-". Обычно перед "--" ставится
% неразрывный пробел "~". Иначе будет как здесь - строка начинается с дефиса.
\item Пусть $k$ -- аппарат, у которого найден вышеописанный цикл, $A$ - множество пар $(i, j)$ таких, что ребро $(i, j)$ является частью цикла. Тогда для данного аппарата добавляем к задаче (3) - (8) следующее линейное ограничение:
\begin{equation}
\displaystyle \sum_{(i,j) \in A} x_{i,j,k} \le |A| - 1
\end{equation}

\item Решаем задачу (3) - (9), переходим к шагу 1.
\end{enumerate}

% ituphanov (3): Надо сослаться работу, в которой вводятся такие ограничения.

\paragraph{Реализация} ~\\
Для формулировки задачи целочисленного программирования на языке программирования C++ использовался фреймверк FlopCpp \cite{hultberg2007flopc++}. Данный фреймверк может использовать различные решатели данных задач. В данной работе использовался решатель SYMPHONY \cite{ralphs2005symphony}.

% ituphanov (3): Нужно сказать,
% что также существует проблема нецелых решений, но она решается фреймвёрком с помощью метода
% ветвей и границ (как я подозреваю).

% Про целочисленное программирование в докладе надо понять что говорить. Потому что
% это интересно, но мы не получили от него хорошей скорости работы. Можно будет
% один слайд показать и сказать, типа, вот делали, но скорость работы оказалась
% неприемлемой, и мы решили не продолжать. А если спросят, мол, нафига вы нам это
% рассказываете, надо объяснить, что этот метод всё равно перспективный, и над ним
% надо просто отдельно работать. Потому что точные решения для коммивояжёра современные
% строятся именно так.

% ituphanov (2): В разделе, который только что закончился, ничего не сказано о методе ветвей
% и границ, внешнем фреймворке, который ты использовал, а также о том, какие условия ты
% применяешь чтобы избавиться от циклов.

\subsubsection{Жадный алгоритм}
Жадный алгоритм действует следующим образом.

% ituphanov (2): Тяжеловато из этого что-то понять. Может быть имеет смысл написать в псевдокоде.

% ituphanov (2): Кстати, а как ты в жаднике выбираешь вариант задания? Если его выбирать так же,
% как ты это делаешь динамикой в ГА, не станет ли жадник выигрывать ГА на регулярных паттернах?

\begin{enumerate}
\item Для каждого задания будем определять, какому аппарату его выгоднее всего отдать на данный момент.
\item Для этого будем назначать задание аппарату $q$, с текущим планом $p_q$ в том случае, если существует такой вариант задания, что при вставке его в некоторую позицию плана $p_q$, мы получим новый план $\widetilde{p_q}$ такой, что время его выполнения будет минимально возможным для всех возможных вставок данного задания в план.
\end{enumerate}
\subsubsection{Генетический алгоритм}


\section{Тестирование}
\subsection{Целочисленное программирование}
\subsubsection{Бинарный поиск максимума с оптимизацией суммы}
\subsubsection{Оптимизация максимума}
\subsection{Жадный алгоритм}
\subsection{Генетический алгоритм}

\section{Заключение}

\pagebreak

\bibliographystyle{ugost2008}
\bibliography{report}


\end{document}