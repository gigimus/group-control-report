\documentclass[a4paper,14pt,russian]{article}

\usepackage{extsizes}
\usepackage{cmap} % для кодировки шрифтов в pdf
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage[T1,T2A]{fontenc}

\usepackage{graphicx} % для вставки картинок
\usepackage{amssymb,amsfonts,amsmath,amsthm} % математические дополнения от АМС
\usepackage{indentfirst} % отделять первую строку раздела абзацным отступом тоже
\usepackage[usenames,dvipsnames]{color} % названия цветов
\usepackage{makecell}
\usepackage{multirow} % улучшенное форматирование таблиц

\usepackage{hyperref}
\usepackage{url}

% ituphanov: Поля вроде не прописаны. Они большие какие-то.
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

% ituphanov (2): Не понятно зачем ты это закомментировал. Вроде как в требованиях всегда был
% интервал полуторный.
\linespread{1.3} % полуторный интервал
\renewcommand{\rmdefault}{ftm} % Times New Roman
\frenchspacing

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage}
\fancyheadoffset{0mm}
\fancyfootoffset{0mm}
\setlength{\headheight}{17pt}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancypagestyle{plain}{
    \fancyhf{}
    \rhead{\thepage}}
\setcounter{page}{2}

\usepackage[tableposition=top]{caption}
\usepackage{subcaption}
\DeclareCaptionLabelFormat{gostfigure}{Рисунок #2}
\DeclareCaptionLabelFormat{gosttable}{Таблица #2}
\DeclareCaptionLabelSeparator{gost}{~---~}
\captionsetup{labelsep=gost}
\captionsetup[figure]{labelformat=gostfigure}
\captionsetup[table]{labelformat=gosttable}
\renewcommand{\thesubfigure}{\asbuk{subfigure}}


\begin{document}
\tableofcontents
\newpage

\section*{Аннотация}

В работе описывается программа для построения оптимального плана выполнения заданий несколькими аппаратами. Работа выполнена в рамках системы управления АНПА для подводных аппаратов ДВФУ и ИПМТ ДВО РАН. Рассмотрен ряд алгоритмов для реализации такого построения. Проведено их тестирование на сгенерированных и составленных в ручную тестах, после чего наиболее эффективные алгоритмы для различных размеров входных данных внедрены в систему управления.

\section{Введение}
\subsection{Глоссарий}
\begin{itemize}
\item АНПА -- Автономный необитаемый подводный аппарат \cite{auv}.
\item СПУ -- Система программного управления.
\item ИПМТ -- Институт проблем морских технологий ДВО РАН.
\item MTSP -- Multiple Traveling Salesman Problem или множественная задача коммивояжера \cite{bektas2006multiple}.
\item ГА -- генетический алгоритм \cite{ga}.
\end{itemize}

\subsection{Описание предметной области}

Одна из областей применения автономных необитаемых подводных аппаратов заключается в решении обзорно-поисковых задач. В рамках таких задач аппаратами покрывается некоторая площадь под водой с целью, например, построения карты с нанесенными результатами измерений, либо с целью поиска и обследования заданных объектов.

В настоящее время ведутся исследования методов, которые позволят более эффективно решать обзорно-поисковые задачи за счет интеллектуализации аппаратов.
Все больше методов концентрируются на эффективном использовании группы АНПА для решения подобных задач.

Например, в работе \cite{cannell2006boundary} описывается алгоритм использования группы подводных аппаратов для обнаружения шлейфов теплой воды с атомной электростанции в морской среде.
Имеется также опыт успешного использования АНПА для поиска затонувших объектов.
Так, в работе \cite{purcell2011use} описывается случай успешного использования автономных подводных аппаратов для обнаружения авиалайнера, потерпевшего крушение в водах Атлантического океана, спустя год после происшествия.

В России исследования по разработке более эффективных методов решения обзорно-поисковых задач с использованием подводных аппаратов ведутся в ИПМТ ДВО РАН и ДВФУ. Первые исследования методов, основанных на централизованном управлении группой АНПА, описаны в работах \cite{tuphanov1} и \cite{tuphanov2}. В этих работах аппараты используются для обследования локальных неоднородностей морской среды.



\subsection{Неформальная постановка задачи}

% описание конкретных предметных областей, примеры использования
% Часть взять из формальной постановке
% планирование в реальном времени, порядок величины миссии
% Перепланирование из-за различных сбоев или добавлений новых аппаратов
% время наработки на отказ
% батарея
% упоминание конкретных аппаратов
% Перепланирование по причине изменения входных данных (добавление-удаление аппаратов, изменение заданий, причины этого, добавление, удаление заданий)
% Почему модель учитывает некоторые факторы а некоторые - нет
% Время поворота, размеры лодок, реальные планы, карты
% Как покрываем площади?
% Почему решаем такую общую задачу.
% Почему разбиваем задачу на две (составление заданий и распределения), а не составляем сразу оптимальные траектории
% Предполагаем
% Улучшить в рамках существующей системы

В настоящее время в ДВФУ организация работы группы аппаратов осуществляется следующим образом:
\begin{enumerate}
\item Заранее составляются задания для аппаратов. Отдельное задание может заключаться в прохождении от одной точки подводной среды к другой с заданной скоростью, возможно, с заданной траекторией, с целью съемки дна гидролокатором, замера параметров водной среды и т.п.
\item Далее, система управления аппаратами, запущенная с настольного ПК или ноутбука, определяет множество аппаратов, между которыми необходимо оптимальным образом распределить вышеописанные задания.
\item Затем СПУ запускает алгоритм-планировщик для поиска оптимального распределения заданий между аппаратами. Этот алгоритм для каждого аппарата определит план (последовательность заданий), который аппарату необходимо выполнить. Каждое задание может выполнять только один аппарат, единственный раз.
\item Индивидуальные планы рассылаются аппаратам по сети, после чего начинается их выполнение.
\end{enumerate}

Во время выполнения планов могут возникать непредвиденные ситуации, такие как:
\begin{itemize}
\item Появление нового аппарата, готового к выполнению заданий
\item Выход аппарата из строя. Это может произойти как по причине поломки, так и ввиду того, что все аппараты используют батареи для электропитания, которые разряжаются в течение нескольких часов.
\item Могут появиться новые задания, по причине, например, обнаружения аппаратами новых локальных неоднородностей.
\item Существующие задания могут измениться. Может измениться время, которое аппарату необходимо потратить на выполнение задания, могут измениться начальные и конечные точки в виду перемены подводных течений, либо помех из за появления новых объектов в морской акватории.
\end{itemize}

В случае возникновения любой из вышеперечисленных непредвиденных ситуаций, СПУ составляет план заново, учитывая занятость аппаратами выполнением заданий, которые нельзя прерывать, и принимая во внимания изменившиеся данные для планирования. Обновленные планы аппаратов рассылаются по сети. Каждый аппарат начинает выполнять новый план по завершению последнего задания, в котором был задействован.

В существующей СПУ алгоритм поиска оптимального плана выполнения заданий работает слишком медленно. По этой причине лабораторией необитаемых подводных аппаратов и их систем в ДВФУ была предложена задача, разработать и исследовать новые алгоритмы планирования заданий между группой АНПА с целью их последующего внедрения в систему управления.

\subsection{Обзор существующих решений}

Существует большое множество алгоритмов, использующихся для решения задачи централизованного планирования заданий для группы аппаратов.
Все найденные подходы используют алгоритмы решения известной задачи дискретной оптимизации, MTSP, в разных ее вариантах.
В такой задаче каждому заданию соответствует единственная точка пространства, которую необходимо посетить единственный раз, только одному аппарату.

Один из вариантов постановки задачи MTSP выглядит следующим образом:
\begin{itemize}
\item Имеется граф $G(V, E)$
\item $V = {v_0, v_1, ... , v_n}$ -- множество вершин ($v_0$ - единственная стартовая позиция всех аппаратов, $v_1, ..., v_n$ -- координаты точек-заданий)
\item $E$ -- множество ребер $\{(v_i, v_j) | i \neq j\}$. Каждое ребро означает наличие перехода между соответствующими ему заданиями. Применительно к подводным аппаратам граф $G$, как правило, является полным.
\item $C$ -- матрица весов $c_{i,j}$ каждого ребра (стоимость перехода между заданиями)
\item $R_k$ -- маршрут $k$-го аппарата, $k=1..m$ (неразрывная последовательность ребер)
\item $\widetilde{C}(R_k) = \displaystyle\sum_{(v_i, v_j) \in R_k} c_{i,j}$ - стоимость маршрута $R_i$
\end{itemize}
Задача состоит в определение такого множества из $m$ маршрутов, что наибольшая стоимость маршрута является минимально возможной:
\begin{equation}
\displaystyle \max_{k=1..m} \widetilde{C}(R_k) \rightarrow \min
\end{equation}

В других вариантах может меняться оптимизируемый функционал, стартовых позиций может быть несколько, и так далее. Подробнее о данной задаче и о методах ее решения можно узнать в работе \cite{bektas2006multiple}.
В частности, в \cite{binaryprog} описан метод, основанный на применении целочисленного программирования к решению MTSP с различными исходными положениями аппаратов.

Однако, большинство подходов находят приближенное решение множественной задачи коммивояжера, так как точные алгоритмы работают медленно. В работе \cite{kiraly2010novel} к решению MTSP применен генетический алгоритм, а в \cite{na2007heurisic} описаны эвристические методы распределения заданий между аппаратами с последующим решением задачи коммивояжера для каждого из них в отдельности.

В ИПМТ ДВО РАН и ДВФУ для решения задачи планирования используют решение, описанное в работе \cite{tuphanov1}. Данное решение является точным в рамках используемой модели, но работает слишком медленно для необходимого количество заданий и аппаратов. В связи с этим необходимо исследование других подходов к задаче группового управления.

Заказчиком также была предложена новая модель для постановки исходной задачи, в рамках которой и работает вышеупомянутое решение. Она также описана в работе \cite{tuphanov1}. Ни один из найденных методов ее не рассматривает, поэтому некоторые из них решено было доработать для решения задачи в рамках новой модели.

\section{Математические методы}

\subsection{Постановка задачи}
В данном разделе описывается модель, использующаяся для решения задачи планирования в СПУ заказчика.

Предполагается, что имеется $m$ аппаратов и $n$ заданий. Планирование происходит перед началом миссии. Известно, что $q$-ый аппарат в начальный момент времени находится в точке $s_q$ и готов к выполнению заданий. Вводится функция $d_q(\mathbf{a}, \mathbf{b})$, обозначающая время перехода АНПА от точки $\mathbf{a}$ к точке $\mathbf{b}$. Она принимает вид $d_q(\mathbf{a}, \mathbf{b}) = |\mathbf{a} - \mathbf{b}| / u_q$, где $u_q$ - максимальная скорость $q$-го аппарата. Для $i$-го задания дано $v_i$ вариантов его выполнения и $j$-ый вариант характеризуется тройкой $(\mathbf{a}_{i, j}, \mathbf{b}_{i,j}, l_{i,j})$, обозначающей соответственно точку начала задания, точку окончания и время его выполнения.

% Пример чему равно l_i_j, но мы не привязываемся, потому-то потому-то

Планом аппарата назван кортеж пар $p = (i_1, j_1), (i_2, j_2), ..., (i_{|p|}, j_{|p|})$ такой, что $i_k \in 1..n, j_k \in 1..v_{i_k}$, для всех $k \in 1..|p|$. Выполнение плана $q$-м аппаратом начинается в точке $\mathbf{s}_q$ и заканчивается в точке $\mathbf{b}_{i_{|p|}, j_{|p|}}$. Время выполнения аппаратом с номером $q$ плана $p$, составляет:

\begin{equation}
t_q(p_q) = d(\mathbf{s}_q, \mathbf{a}_{i_1, j_1}) + \sum_{k=2}^{|p|} d_q(\mathbf{b}_{i_{k-1}, j_{k - 1}}, \mathbf{a}_{i_k, j_k}) + \sum_{k=1}^{|p|}l_{i_k, j_k}
\end{equation}

% % соответствие между планами и аппаратами
Общим планом является кортеж планов $P = (p_1, p_2, ..., p_m)$ такой, что каждое здание встречается среди его планов один раз и в одном варианте. Время выполнения общего плана определяется выражением:

\begin{equation}
t(P) = \displaystyle \max_{q \in 1..m} t_q(p_q)
\end{equation}

Задача состоит в том, чтобы при данных стартовых позициях $\mathbf{s}_q$, известных заданиях и вариантах их выполнения найти общий план $P$, минимизирующий $t(P)$.

% Заданная функция d_q

% ituphanov (2): Вполне возможно, что далее по тексту надо будет ссылаться на задачу оптимизации.
% Тогда удобно сделать, чтобы она была выражено какой-то нумерованой формулой, поэтому может
% иметь смысл сделать формулу типа t(P) -> min.

\subsection{Алгоритмы}
\subsubsection{Целочисленное программирование}

В настоящем разделе описывается алгоритм нахождения точного решения к поставленной задаче с помощью алгоритмов, использующих методы целочисленного программирования. В сравнении с вариантной моделью был сделан ряд упрощений:
% ituphanov (2): Вот здесь впервые употреблён термин "вариантная модель". Надо или выше ввести
% этот термин, там где ты вводишь модель, или ссылаться на неё как на "модель (1)-(3)".

% ituphanov (3): Нужно или поставить точку в конце каждого пункта перечисления, или
% сделать каждый пункт с маленькой буквы и после каждого кроме последнего ставить точку запятой.

\begin{itemize}
\item Все задания имеют ровно один вариант выполнения
\item У каждого задания начальная и конечная точки совпадают
\item Временные затраты на выполнение самих заданий аппаратами пренебрежимо малы
\item Скорости аппаратов одинаковы
\item Аппараты в начальный момент времени готовы к выполнению миссии
\item Для описания координат аппаратов и заданий используется двумерная декартова система координат
\end{itemize}


\paragraph{Сведение исходной задачи к MTSP} ~\\

Для постановки задачи MTSP необходимо ввести ориентированный граф.

Вершинами графа будут являться задания, стартовые вершины аппаратов и одна фиктивная вершина, необходимая только для постановки задачи коммивояжера.

От фиктивной вершины проведены ребра к стартовым вершинам аппаратов. От стартовых вершин аппаратов проведены ребра к каждой вершине заданий. Вершины заданий соединены ребрами между собой, образуя полный подграф. То есть ребра проведены между всеми парами вершин в обоих направлениях. Также, проведены ребра от вершин заданий к фиктивной вершине.

Весом каждого ребра будет расстояние между координатами заданий либо стартовых вершин. Вес ребер, инцидентных, фиктивной вершине равен нулю.

Решением задачи MTSP будет являться система циклов, удовлетворяющих требованиям MTSP, при этом стоимость максимального цикла будет минимально возможной. Каждому аппарату соответствует ровно один цикл. Двигаясь в этом цикле по направленным ребрам от стартовой вершины и заканчивая в фиктивной вершине, добавляя каждую вершину в план, мы получим оптимальный план этого аппарата.

% ituphanov (3): Если бы ты писал книгу (или статью), то несколько предыдущих абзацев точно
% надо было бы переделать. Потому что ты объяснил на пальцах и можно как-то не так это понять.
% Потому что встречаются словосочетания "вершина аппарата", и когда пытаешься понять что это
% такое, то видишь "стартовая вершина аппарата". При этом может создаться впечатление, что
% ты путаешь вершины графа и точки на плоскости (хотя, мы оба знаем, что не путаешь).
% Более правильным был бы способ описания, где ты ввёл бы обозначения для графа G, множества
% рёбер E, множества вершин V, подмножеств множества V, отвечающих за разные вещи,
% фиктивной вершины и т.д. и описал бы весовую функцию его рёбер. Какие-то из рёбер весят 0,
% какие-то - бесконечность, а какие-то ровно столько, каково расстояние между соответствующими
% точками на плоскости. Вершины можно также занумеровать (как ты это сделал ниже).
% Тогда можно нарисовать красивую матрицу для весовой функции, и использовать введённые
% обозначения ниже при описании задачи ЛП.
% Хорошо бы всё это сделать, если будет время.

% Вставить пример графа.


\paragraph{Постановка задачи целочисленного программирования} ~\\

Вводим бинарные переменные $x_{i,j,k}$, где $i, j$ -- номера вершин графа, $k$ -- номер аппарата. Полагаем $x_{i,j,k}$ равным единице, если в цикле, соответствующему аппарату $k$, есть ребро $(i, j)$, и нулю -- в противоположном случае. Вершина с индексом $0$ - фиктивная.

Добавляем следующие ограничения:
\begin{itemize}

\item Каждый аппарат должен иметь у себя в цикле ровно одно ребро, входящее в фиктивную вершину и выходящее из нее:

% ituphanov (3): Как-то в pdf-ке выглядит слепленной сумма и значок \forall k.
% Надо посмотреть как они в книжках по математике пишут. Там он тоже слеплен?

\begin{equation}
\forall k \displaystyle\sum_j x_{0,j,k} = \displaystyle\sum_i x_{i,0,k} = 1
\end{equation}

\item Сумма ребер, выходящих из любой вершины, кроме фиктивной, должна быть равна сумме ребер, входящих в нее и равна единице:
\begin{equation}
\forall i \neq 0 \displaystyle\sum_j \displaystyle\sum_k x_{i,j,k} = \displaystyle\sum_j \displaystyle\sum_k x_{j,i,k} = 1
\end{equation}

\end{itemize}

Обозначим вес ребра $(i, j)$ как $w_{i,j}$. Тогда стоимость маршрута каждого аппарата:
\begin{equation}
c_k(\mathbf{x}) = \displaystyle\sum_i \displaystyle\sum_j w_{i,j} x_{i,j,k}
\end{equation}

% ituphanov (3): В ограничениях и в целевой функции нигде не участвуют стартовые вершины
% аппаратов. Они могли исчезнуть, став обычными вершинами i, j, но тогда одному аппарату
% нельзя залезать на стартовую вершину другого. Или это само собой получается, потому что
% каждый аппарат и так стоит на своей стартовой вершине. В любом случае, на этот вопрос
% надо в тексте как-то ответить.

% ituphanov (3): Так где ты вводишь x i,j,k можно объяснить и что такое жирный x.

\begin{itemize}
\item В первом варианте алгоритма минимизируемым функционалом является
\begin{equation}
\widetilde{c}(\mathbf{x}) = \displaystyle\max_k \{c_k(\mathbf{x})\}
\end{equation}

\item Во втором варианте мы вводим переменную $C_{max}$, оптимальное значение котоорой ищем бинарным поиском. На каждой итерации бинарного поиска проверяем существование решения задачи целочисленного программирования, в которую добавлены ограничения $c_k(\mathbf{x}) \le C_{max}$ и минимизируемым функционалом является сумма:

% ituphanov (2): В этом выражении, равно как и в предыдущем, нет никакого знака "=". Это выглядит
% неудобно. Я бы рекомендовал ввести обозначение для минимизируемого функционала и написать
% что-то типа "f(x) = ...". Это делается потому что когда человек читает твой текст и привыкает
% к обозначениям, ему достаточно посмотреть на формулу и не пытаться что-то выудить из текста
% над ней.
\begin{equation}
\widetilde{c}(\mathbf{x}) = \displaystyle\sum_k c_k(\mathbf{x})
\end{equation}

\begin{equation}
\widetilde{c}(\mathbf{x}) \rightarrow \min
\end{equation}

\end{itemize}


\paragraph{Неравенства циклов} ~\\

При вышеописанной постановке задачи целочисленного программирования мы легко можем получить в качестве решения не один, а систему циклов для одного или нескольких аппаратов. Чтобы этого избежать, необходимо вводить дополнительные линейные ограничения исключающие появление систем циклов. В данной работе использовался следующий метод:
\begin{enumerate}
\item  Ожидаем решения задачи целочисленного программирования.
\item Анализируем решение на наличие систем циклов. Для этого используем поиск в глубину для каждого аппарата.
\item Если поиск в глубину находит цикл, длина которого меньше суммарного количества ребер, задействованных данным аппаратом, значит у данного аппарата в маршруте есть несколько циклов.
% ituphanov (3): "$A$ - мн": здесь нужно вставить второй "-". Обычно перед "--" ставится
% неразрывный пробел "~". Иначе будет как здесь - строка начинается с дефиса.
\item Пусть $k$ -- аппарат, у которого найден вышеописанный цикл, $A$ - множество пар $(i, j)$ таких, что ребро $(i, j)$ является частью цикла. Тогда для данного аппарата добавляем к задаче (3) - (8) следующее линейное ограничение:
\begin{equation}
\displaystyle \sum_{(i,j) \in A} x_{i,j,k} \le |A| - 1
\end{equation}

\item Решаем задачу (3) - (9), переходим к шагу 1.
\end{enumerate}

% ituphanov (3): Надо сослаться работу, в которой вводятся такие ограничения.

\paragraph{Реализация} ~\\
Для формулировки задачи целочисленного программирования на языке программирования C++ использовался фреймверк FlopCpp \cite{hultberg2007flopc++}. Данный фреймверк может использовать различные решатели данных задач. В данной работе использовался решатель SYMPHONY \cite{ralphs2005symphony}.

% ituphanov (3): Нужно сказать,
% что также существует проблема нецелых решений, но она решается фреймвёрком с помощью метода
% ветвей и границ (как я подозреваю).

% Про целочисленное программирование в докладе надо понять что говорить. Потому что
% это интересно, но мы не получили от него хорошей скорости работы. Можно будет
% один слайд показать и сказать, типа, вот делали, но скорость работы оказалась
% неприемлемой, и мы решили не продолжать. А если спросят, мол, нафига вы нам это
% рассказываете, надо объяснить, что этот метод всё равно перспективный, и над ним
% надо просто отдельно работать. Потому что точные решения для коммивояжёра современные
% строятся именно так.

% ituphanov (2): В разделе, который только что закончился, ничего не сказано о методе ветвей
% и границ, внешнем фреймворке, который ты использовал, а также о том, какие условия ты
% применяешь чтобы избавиться от циклов.

\subsubsection{Жадный алгоритм}
Жадный алгоритм действует следующим образом.

% ituphanov (2): Тяжеловато из этого что-то понять. Может быть имеет смысл написать в псевдокоде.

% ituphanov (2): Кстати, а как ты в жаднике выбираешь вариант задания? Если его выбирать так же,
% как ты это делаешь динамикой в ГА, не станет ли жадник выигрывать ГА на регулярных паттернах?

\begin{enumerate}
\item Для каждого задания будем определять, какому аппарату его выгоднее всего отдать на данный момент.
\item Для этого будем назначать задание аппарату $q$, с текущим планом $p_q$ в том случае, если существует такой вариант задания, что при вставке его в некоторую позицию плана $p_q$, мы получим новый план $\widetilde{p_q}$ такой, что время его выполнения будет минимально возможным для всех возможных вставок данного задания в план.
\end{enumerate}
\subsubsection{Генетический алгоритм}


\section{Требования}


% Столкновения бывают но мы о них забиываем
% Программа выполняется на ноутбуке, а не на аппарате

Программа должна:
\begin{itemize}
\item Реализовывать и сравнивать несколько алгоритмов решения задачи планирования
\item Быть совместимой с уже имеющимся API системы планирования заданий для группы подводных аппаратов ДВФУ.
% описать  API
\end{itemize}

Лучшие из реализованных алгоритмов для различных размеров входных данных требуется внедрить в уже использующуся систему планирования заданий для подводных аппаратов ДВФУ, работающую под операционными системами семейства Linux. В результате внедрения новых алгоритмов система должна:
\begin{itemize}

\item Осуществлять планирование до 100 заданий для группы до 5 аппаратов за приемлемое время (до 1 минуты).
\item Выбирать более эффективный алгоритм в зависимости от размеров входных данных для планирования.
\item Допускается отклонение решения от оптимального на некоторых входных данных, в случае если алгоритм, дающий точное решение неэффективно на них работает.
\end{itemize}

% ituphanov (3): У меня есть подозрение, что раздел "алгоритмы" должен идти до раздела "проект".
% Можно даже сделать раздел "мат.методы и алгоритмы" и описать там и модель и алгоритмы.
% А раздел "требования" можно отнести чуть выше, поставить после неформальной постановки задачи.
% Если в репплане не так, то от репплана можно отступить.

\section{Проект}
\subsection{Объектно-ориентированная структура}
Система состоит из следующих модулей
\begin{itemize}
\item Task. Содержит классы:
    \begin{itemize}
    \item pnt. Содержит основной набор функций для работы с двумерными векторами в евклидовом пространстве. % ituphanov (2): Точка.
    \item assigned\_task. Содержит информацию об использованном варианте задания (начальная, конечная точки и время выполнения). % ituphanov (2): Точка. И слово таск надо заменить на литературное.
    \item task\_t. Содержит набор функций для работы с заданиями.
    \item tasks\_type. Контейнер для хранения заданий. Содержит функционал для добавления и доступа к заданиям.
    \end{itemize}
\item Solver. Содержит единственный класс basic\_solver, являющийся базовым ко всем классам, инкапсулирующим различные алгоритмы решения задачи планирования заданий для группы АНПА.
\item Plan. Содержит единственный класс plan\_t, который инкапсулирует работу с общим планом для всех аппаратов.
\item Data. Содержи тединственный класс problem\_data, содержащий входные данные к задаче и предоставляющий к ним доступ.
\item Visualize. Содержит класс visual\_frame, который служит для вывода заданного общего плана для группы аппаратов на экран.
\item MILPSolver. Содержит класс milp\_solver, в котором находится реализация алгоритма, основанного на целочисленном программировании.
\item GreedySolver. Содержит класс greedy\_solver, реализующий жадный подход к решению задачи планирования.
\item GeneticSolver. Содержит класс genetic\_solver, реализующий генетический алгоритм для решения исходной задачи.
\item HKSolver. Содержит класс, содержащий реализацию алгоритма, описанного в \cite{tuphanov1}
\end{itemize}


\section{Тестирование}
\subsection{Целочисленное программирование}
\subsubsection{Бинарный поиск максимума с оптимизацией суммы}
\subsubsection{Оптимизация максимума}
\subsection{Жадный алгоритм}
\subsection{Генетический алгоритм}

\section{Заключение}

\pagebreak

\bibliographystyle{ugost2008}
\bibliography{report}


\end{document}